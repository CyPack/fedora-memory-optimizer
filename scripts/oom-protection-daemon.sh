#!/bin/bash
#═══════════════════════════════════════════════════════════════════════════════
# OOM PROTECTION DAEMON
# Dynamic oom_score_adj management for Fedora Memory Optimizer
#
# This daemon monitors processes and sets oom_score_adj based on categories:
#   IMMORTAL  (-1000): System components - NEVER killed
#   PROTECTED (-900):  IDEs, terminals - Almost never killed
#   NORMAL    (0):     Default apps
#   KILLABLE  (+500):  Browsers - Killed first under memory pressure
#
# Author: Generated by Claude (Anthropic)
# License: MIT
# Version: 1.0.0
#═══════════════════════════════════════════════════════════════════════════════

set -euo pipefail

#───────────────────────────────────────────────────────────────────────────────
# CONFIGURATION
#───────────────────────────────────────────────────────────────────────────────

readonly SCRIPT_NAME="oom-protection-daemon"
readonly SCRIPT_VERSION="1.0.0"
readonly LOG_FILE="/var/log/oom-protection-daemon.log"
readonly PID_FILE="/run/oom-protection-daemon.pid"
readonly CONFIG_FILE="/etc/memory-optimizer/oom-protection.conf"

# Scan interval in seconds
SCAN_INTERVAL=${SCAN_INTERVAL:-5}

# OOM Score values
readonly SCORE_IMMORTAL=-1000
readonly SCORE_PROTECTED=-900
readonly SCORE_NORMAL=0
readonly SCORE_KILLABLE=500

# Colors for logging
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

#───────────────────────────────────────────────────────────────────────────────
# PROCESS CATEGORIES (Regex patterns)
#───────────────────────────────────────────────────────────────────────────────

# IMMORTAL: System components that should NEVER be killed
IMMORTAL_PATTERNS=(
    # GNOME Desktop Environment
    "^gnome-shell$"
    "^mutter"
    "^gsd-"
    "^gnome-session"
    "^gnome-keyring"
    "^evolution-"
    "^goa-"
    "^tracker-"
    "^gjs$"
    "^gnome-software$"
    "^gnome-control-center$"

    # Display
    "^Xorg$"
    "^Xwayland$"
    "^gdm"
    "^mutter-x11-fram"

    # Audio
    "^pipewire$"
    "^pipewire-pulse$"
    "^wireplumber$"
    "^pulseaudio$"

    # System Services
    "^systemd$"
    "^dbus-daemon$"
    "^dbus-broker$"
    "^polkitd$"
    "^accounts-daemon$"
    "^colord$"
    "^udisksd$"
    "^upowerd$"

    # Networking
    "^NetworkManager$"
    "^bluetoothd$"
    "^wpa_supplicant$"

    # Input Methods
    "^ibus-"
    "^fcitx"

    # Other critical
    "^at-spi"
    "^gnome-shell-cal"
    "^xdg-"
    "^gvfs"
    "^dconf"
)

# PROTECTED: User-critical applications
PROTECTED_PATTERNS=(
    # IDEs and Code Editors
    "^code$"
    "^code-insiders$"
    "^vscodium$"
    "^codium$"
    "^idea"
    "^pycharm"
    "^webstorm"
    "^goland"
    "^clion"
    "^phpstorm"
    "^rider"
    "^datagrip"
    "^android-studio"
    "^sublime_text$"
    "^subl$"
    "^atom$"
    "^vim$"
    "^nvim$"
    "^neovim$"
    "^emacs"
    "^gedit$"
    "^gnome-text-editor$"
    "^kate$"
    "^kwrite$"

    # Terminals
    "^gnome-terminal"
    "^alacritty$"
    "^kitty$"
    "^tilix$"
    "^konsole$"
    "^terminator$"
    "^guake$"
    "^yakuake$"
    "^xterm$"
    "^urxvt$"
    "^st$"
    "^foot$"
    "^wezterm"

    # File Managers
    "^nautilus$"
    "^org.gnome.Nautilus$"
    "^dolphin$"
    "^thunar$"
    "^nemo$"
    "^pcmanfm"
    "^caja$"

    # Development
    "^docker$"
    "^dockerd$"
    "^containerd$"
    "^podman$"
    "^buildah$"
)

# KILLABLE: Browsers and communication apps - killed first
KILLABLE_PATTERNS=(
    # Browsers
    "^firefox"
    "^chrome$"
    "^chromium"
    "^google-chrome"
    "^brave"
    "^opera$"
    "^vivaldi"
    "^microsoft-edge"
    "^edge$"
    "^epiphany"
    "^midori$"
    "^falkon$"
    "^qutebrowser$"
    "^min$"
    "^nyxt$"
    "^Web$"
    "^WebKitWebProcess$"

    # Browser helper processes
    "chrome_crashpad"
    "nacl_helper"

    # Communication (browser-based)
    "^slack$"
    "^Slack$"
    "^discord$"
    "^Discord$"
    "^teams$"
    "^microsoft-teams"
    "^zoom$"
    "^skypeforlinux$"
    "^telegram-desktop$"
    "^signal-desktop$"
    "^whatsapp"
    "^element-desktop$"
    "^wire-desktop$"
)

#───────────────────────────────────────────────────────────────────────────────
# LOGGING
#───────────────────────────────────────────────────────────────────────────────

log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"

    if [[ "${VERBOSE:-false}" == "true" ]]; then
        case "$level" in
            INFO)  echo -e "${BLUE}[$level]${NC} $message" ;;
            OK)    echo -e "${GREEN}[$level]${NC} $message" ;;
            WARN)  echo -e "${YELLOW}[$level]${NC} $message" ;;
            ERROR) echo -e "${RED}[$level]${NC} $message" ;;
            *)     echo "[$level] $message" ;;
        esac
    fi
}

log_info()  { log "INFO" "$@"; }
log_ok()    { log "OK" "$@"; }
log_warn()  { log "WARN" "$@"; }
log_error() { log "ERROR" "$@"; }

#───────────────────────────────────────────────────────────────────────────────
# HELPER FUNCTIONS
#───────────────────────────────────────────────────────────────────────────────

# Get process name from PID
get_process_name() {
    local pid="$1"
    cat "/proc/$pid/comm" 2>/dev/null || echo ""
}

# Get current oom_score_adj
get_oom_score() {
    local pid="$1"
    cat "/proc/$pid/oom_score_adj" 2>/dev/null || echo ""
}

# Set oom_score_adj for a process
set_oom_score() {
    local pid="$1"
    local score="$2"
    local name="$3"
    local file="/proc/$pid/oom_score_adj"

    # Try to write directly
    if [[ -f "$file" ]]; then
        # Use subshell to capture write errors
        if ( echo "$score" > "$file" ) 2>/dev/null; then
            log_ok "Set oom_score_adj=$score for $name (PID $pid)"
            return 0
        else
            log_warn "Failed to set score for $name (PID $pid)"
            return 1
        fi
    fi
    return 1
}

# Check if process matches any pattern in array
matches_patterns() {
    local name="$1"
    shift
    local patterns=("$@")

    for pattern in "${patterns[@]}"; do
        if [[ "$name" =~ $pattern ]]; then
            return 0
        fi
    done
    return 1
}

# Determine the category for a process
categorize_process() {
    local name="$1"

    if matches_patterns "$name" "${IMMORTAL_PATTERNS[@]}"; then
        echo "IMMORTAL"
    elif matches_patterns "$name" "${PROTECTED_PATTERNS[@]}"; then
        echo "PROTECTED"
    elif matches_patterns "$name" "${KILLABLE_PATTERNS[@]}"; then
        echo "KILLABLE"
    else
        echo "NORMAL"
    fi
}

# Get score for category
get_category_score() {
    local category="$1"

    case "$category" in
        IMMORTAL)  echo "$SCORE_IMMORTAL" ;;
        PROTECTED) echo "$SCORE_PROTECTED" ;;
        KILLABLE)  echo "$SCORE_KILLABLE" ;;
        *)         echo "$SCORE_NORMAL" ;;
    esac
}

#───────────────────────────────────────────────────────────────────────────────
# MAIN FUNCTIONS
#───────────────────────────────────────────────────────────────────────────────

# Process a single PID
process_pid() {
    local pid="$1"

    # Skip if not a valid PID directory
    [[ ! -d "/proc/$pid" ]] && return

    # Skip kernel threads (no cmdline)
    # Note: -s test doesn't work on /proc filesystem, must read content
    # Use tr to remove NULL bytes that cause bash warnings
    local cmdline=$(tr -d '\0' < "/proc/$pid/cmdline" 2>/dev/null)
    [[ -z "$cmdline" ]] && return

    local name=$(get_process_name "$pid")
    [[ -z "$name" ]] && return

    local current_score=$(get_oom_score "$pid")
    [[ -z "$current_score" ]] && return

    local category=$(categorize_process "$name")

    # Skip NORMAL category - don't change default scores
    [[ "$category" == "NORMAL" ]] && return

    local target_score=$(get_category_score "$category")

    # Update if score is different from target
    if [[ "$current_score" != "$target_score" ]]; then
        set_oom_score "$pid" "$target_score" "$name" || true
    fi
}

# Scan all processes
scan_all_processes() {
    local count_immortal=0
    local count_protected=0
    local count_killable=0
    local count_total=0

    for pid_dir in /proc/[0-9]*; do
        local pid=$(basename "$pid_dir")

        # Skip non-numeric (safety check)
        [[ ! "$pid" =~ ^[0-9]+$ ]] && continue

        process_pid "$pid"

        # Count for stats
        local name=$(get_process_name "$pid" 2>/dev/null)
        [[ -z "$name" ]] && continue

        local category=$(categorize_process "$name")
        case "$category" in
            IMMORTAL)  count_immortal=$((count_immortal + 1)) ;;
            PROTECTED) count_protected=$((count_protected + 1)) ;;
            KILLABLE)  count_killable=$((count_killable + 1)) ;;
        esac
        count_total=$((count_total + 1))
    done

    log_info "Scan complete: $count_total processes (IMMORTAL: $count_immortal, PROTECTED: $count_protected, KILLABLE: $count_killable)"
}

# Initial setup - set scores for all existing processes
initial_setup() {
    log_info "Starting initial process scan..."
    scan_all_processes
    log_ok "Initial setup complete"
}

# Main daemon loop
daemon_loop() {
    log_info "Starting daemon loop (interval: ${SCAN_INTERVAL}s)"

    while true; do
        scan_all_processes
        sleep "$SCAN_INTERVAL"
    done
}

# Run once (for manual testing)
run_once() {
    log_info "Running single scan..."
    scan_all_processes

    echo ""
    echo "Current OOM scores for key processes:"
    echo "======================================"

    for proc in gnome-shell mutter pipewire code firefox chrome; do
        for pid in $(pgrep "$proc" 2>/dev/null); do
            local name=$(get_process_name "$pid")
            local score=$(get_oom_score "$pid")
            local category=$(categorize_process "$name")
            printf "%-25s PID %-8s Score: %-6s Category: %s\n" "$name" "$pid" "$score" "$category"
        done
    done
}

# Show status
show_status() {
    echo "OOM Protection Daemon Status"
    echo "============================"
    echo ""

    # Count by category
    echo "Process counts by category:"
    local immortal=0 protected=0 killable=0 normal=0

    for pid_dir in /proc/[0-9]*; do
        local pid=$(basename "$pid_dir")
        [[ ! "$pid" =~ ^[0-9]+$ ]] && continue
        # Note: -s test doesn't work on /proc filesystem
        [[ -z "$(tr -d '\0' < /proc/$pid/cmdline 2>/dev/null)" ]] && continue

        local name=$(get_process_name "$pid" 2>/dev/null)
        [[ -z "$name" ]] && continue

        local score=$(get_oom_score "$pid" 2>/dev/null)
        [[ -z "$score" ]] && continue

        if [[ "$score" -le -1000 ]]; then
            immortal=$((immortal + 1))
        elif [[ "$score" -le -500 ]]; then
            protected=$((protected + 1))
        elif [[ "$score" -ge 500 ]]; then
            killable=$((killable + 1))
        else
            normal=$((normal + 1))
        fi
    done

    echo "  IMMORTAL  (score <= -1000): $immortal"
    echo "  PROTECTED (score <= -500):  $protected"
    echo "  NORMAL    (score ~0):       $normal"
    echo "  KILLABLE  (score >= 500):   $killable"
    echo ""

    # Show specific processes
    echo "Key protected processes:"
    for proc in gnome-shell mutter gsd pipewire code; do
        for pid in $(pgrep "$proc" 2>/dev/null | head -3); do
            local name=$(get_process_name "$pid")
            local score=$(get_oom_score "$pid")
            printf "  %-25s (PID %s): %s\n" "$name" "$pid" "$score"
        done
    done
    echo ""

    echo "Key killable processes (browsers):"
    for proc in firefox chrome chromium brave; do
        for pid in $(pgrep "$proc" 2>/dev/null | head -3); do
            local name=$(get_process_name "$pid")
            local score=$(get_oom_score "$pid")
            printf "  %-25s (PID %s): %s\n" "$name" "$pid" "$score"
        done
    done
}

#───────────────────────────────────────────────────────────────────────────────
# SYSTEMD SERVICE FUNCTIONS
#───────────────────────────────────────────────────────────────────────────────

start_daemon() {
    # Check if already running
    if [[ -f "$PID_FILE" ]]; then
        local old_pid=$(cat "$PID_FILE")
        if kill -0 "$old_pid" 2>/dev/null; then
            log_error "Daemon already running with PID $old_pid"
            exit 1
        fi
        rm -f "$PID_FILE"
    fi

    # Create log directory if needed
    mkdir -p "$(dirname "$LOG_FILE")"
    touch "$LOG_FILE"

    log_info "OOM Protection Daemon v$SCRIPT_VERSION starting..."

    # Store PID
    echo $$ > "$PID_FILE"

    # Trap signals
    trap 'log_info "Received SIGTERM, shutting down..."; rm -f "$PID_FILE"; exit 0' SIGTERM
    trap 'log_info "Received SIGINT, shutting down..."; rm -f "$PID_FILE"; exit 0' SIGINT

    # Initial setup
    initial_setup

    # Main loop
    daemon_loop
}

stop_daemon() {
    if [[ -f "$PID_FILE" ]]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            kill -TERM "$pid"
            log_info "Sent SIGTERM to daemon (PID $pid)"
            rm -f "$PID_FILE"
        else
            log_warn "Daemon not running, removing stale PID file"
            rm -f "$PID_FILE"
        fi
    else
        log_warn "No PID file found"
    fi
}

#───────────────────────────────────────────────────────────────────────────────
# MAIN
#───────────────────────────────────────────────────────────────────────────────

usage() {
    cat << EOF
OOM Protection Daemon v$SCRIPT_VERSION

Usage: $0 [OPTIONS] COMMAND

Commands:
    start       Start the daemon (for systemd)
    stop        Stop the daemon
    run-once    Run a single scan (for testing)
    status      Show current OOM protection status

Options:
    -v, --verbose   Verbose output
    -h, --help      Show this help

Examples:
    sudo $0 start           # Start as daemon
    sudo $0 run-once        # Single scan
    $0 status               # Show status (no sudo needed)

Environment Variables:
    SCAN_INTERVAL   Seconds between scans (default: 5)
    VERBOSE         Enable verbose logging (true/false)

EOF
}

main() {
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            start|stop|run-once|status)
                COMMAND="$1"
                shift
                break
                ;;
            *)
                echo "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Require command
    if [[ -z "${COMMAND:-}" ]]; then
        usage
        exit 1
    fi

    # Execute command
    case "$COMMAND" in
        start)
            [[ $EUID -ne 0 ]] && { echo "Error: start requires root"; exit 1; }
            start_daemon
            ;;
        stop)
            [[ $EUID -ne 0 ]] && { echo "Error: stop requires root"; exit 1; }
            stop_daemon
            ;;
        run-once)
            [[ $EUID -ne 0 ]] && { echo "Error: run-once requires root"; exit 1; }
            run_once
            ;;
        status)
            show_status
            ;;
        *)
            echo "Unknown command: $COMMAND"
            usage
            exit 1
            ;;
    esac
}

main "$@"
